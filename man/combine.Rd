% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/is.R
\name{combine}
\alias{&}
\alias{&.IsFunction}
\alias{combine}
\alias{xor}
\alias{xor.IsFunction}
\alias{xor.default}
\alias{|}
\alias{|.IsFunction}
\title{Combination of is* conditions}
\usage{
\method{&}{IsFunction}(x, y)

\method{|}{IsFunction}(x, y)

\method{xor}{IsFunction}(x, y)

xor(x, y)

\method{xor}{default}(x, y)
}
\arguments{
\item{x, y}{two logical statements (\code{\link{is}} functions) which should
be combined}
}
\description{
Logical tests as defined by \code{is*} functions can be combined by the
standard logical operators \code{\link{&}}, \code{\link{|}}, and
\code{\link{xor}}.
}
\details{
If both tests are strict tests (that is, they were called by
setting 'strict.' to TRUE [the default], which can be checked by
\code{\link{isStrict}}), the tests are combined in the standard fashion.\cr
However, if at least one of the tests is optional (strict. = FALSE), the
combined result is going to be returned by the new test only if it contains
at least one TRUE value. Otherwise, it will return the result of the strict
test alone, or if both tests are optional, only FALSE values will be
returned.\cr
Note that \code{xor} has been made generic and a new \code{xor.default}
method was added besides \code{xor.IsFunction}. The new default method
is much faster than \code{base::xor} and is authored by Jens Oehlschlagel
(see \code{?xor} in package \bold{bit}).
}
\examples{
# define two strict constraints and combine them
check_above_10 <- isBetween(lwr. = 10, open. = "lwr")
check_local_max <- isLocalMaximum()
check_local_max_above_10 <- check_local_max & check_above_10

# call the combined test on the following vector
vec <- c(0, 1, 0, 11, 0, 21, 0)
( res <- check_local_max_above_10(vec) )
stopifnot(identical(
    c(res),
    c(FALSE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE)
))

# make the above_10 constraint optional
check_maybe_above_10 <- isBetween(lwr. = 10, open. = "lwr", strict. = FALSE)
check_local_max_maybe_above_10 <- check_local_max & check_maybe_above_10

# call the combined test on the vector
( res2 <- check_local_max_maybe_above_10(vec) )

# the results are identical, because the combined test is TRUE for at least
# one data point
stopifnot(identical(
    c(res), c(res2)
))

# now change the test vector with no local maximum above 10,
# and run the test
vec3 <- c(0, 1, 0)
( res3 <- check_local_max_maybe_above_10(vec3) )

# here, the optional test is ignored
stopifnot(identical(
    res3, check_local_max(vec3)
))
}

