% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/matstat.R
\name{findExtrema}
\alias{findExtrema}
\title{Find local peaks (maxima) and valleys (minima) of a vector}
\usage{
findExtrema(x, n = 1L, along_dim = 1L, tail = c("if_plateau", "never",
  "do_not_care"), has_NA = NULL)
}
\arguments{
\item{x}{an integer or numeric vector, matrix, or array}

\item{n}{the number of neighbouring points (default: 1L) to the left and to
the right of each data point; a data point is a local minimum/maximum if it
is below/above all data points in its neighbourhood. See Details.}

\item{along_dim}{the dimension of \code{x} which defines the vectors that
should be tested for local extrema. If \code{along_dim} is of type character,
\code{x} must have named dimnames.}

\item{tail}{character string defining how tails should be handled (might be
abbreviated): "if_plateau" (the default) means extrema at the tails of the
vector are only valid if they are part of a plateau; "never" means no
extrema at the tails; "do_not_care" means no special treatment of extrema
at the tails}

\item{has_NA}{if FALSE, x is not checked for missing values, thereby speeding
up the computations; if has_NA is NULL (default), a fast check is performed
and if x has missing values, special corrections are applied (see Details).}
}
\value{
\code{findExtrema} returns an object of the same shape and length
as \code{x}, recoding the original values in \code{x} to integer values 1
(local maximum), -1 (local minimum), and 0 (neither minimum nor maximum), or
NA (not available).
}
\description{
\code{findExtrema} identifies local peaks and valleys of a vector (or
subviews of a matrix or array)
}
\details{
There are three special features of \code{findExtrema}. First,
repeated neighbouring values ('plateaus') are treated as if they were a
single data point. This has two consequences: 1) If the plateau is a local
extrema, all points of the plateau are considered as extrema. 2) The
argument 'n' of \code{findExtrema} is applied on the 'unitized' (de-repeated)
vector.\cr
Second, extrema at the tails (the first and last elements of the vector)
are often problematic, because for those data points, only one-sided
comparisons are available. By default, \code{findExtrema} considers such
endpoints as local minima/maxima if they are part of a plateau (i.e. if
the endpoint is equal to its nearest neighbour). However, this behaviour
can be changed by setting the argument 'tail' to "never" or "do_not_care".\cr
Third, neighbours of a missing value are returned as missing values because
if a given data window has at least one missing value, no minimum or
maximum can be computed.
}
\examples{
# create a vector with two local minima and one local maximum
x <- c(10, 3, 1, 2, -1, 0, 4, 5)

# find local minima/maxima
(x_extr <- findExtrema(x))

# the same with a more stringent criterion
(x_extr2 <- findExtrema(x, 2L))

# note that findExtrema always returns an integer vector or matrix
stopifnot(is.integer(x_extr))

# check results
stopifnot(identical(x[x_extr < 0L], c(1, -1)))
stopifnot(identical(x[x_extr > 0L], 2))
stopifnot(identical(x[x_extr2 != 0L], -1))

# modify the vector to have a plateau at the start, and a missing value at
# the position 7; consider only the nearest neighbours
x <- c(10, x)
x[7] <- NA
x

# now the first two elements should also be identified as local maxima,
# but the value -1 is not a local minimum any more because there is a
# missing value in its neighbourhood
(x_extr <- findExtrema(x))
stopifnot(all(x_extr[1:2] == 1L))
stopifnot(all(is.na(x_extr[6:8])))

# visualize the results (blue: local minimum, red: local maximum)
plot(x, type = "l", lty = 3)
points(x, pch = 16, col = c("blue", "grey", "red")[findExtrema(x) + 2L])

#' # however, if 'tail' is set to "never", the first two elements are not
# extrema
(x_extr <- findExtrema(x, tail = "n"))
stopifnot(all(x_extr[1:2] == 0L))

# x can be a matrix (or even an array)
x <- cbind(sin(seq(0, 3*pi, pi/4)), cos(seq(0, 3*pi, pi/4)))
(x_extr <- findExtrema(x))
matplot(x, type = "l", lty = 3, col = 1)
points(x[, 1L], pch = 16,
       col = c("blue", "grey", "red")[findExtrema(x[, 1L]) + 2L])
points(x[, 2L], pch = 16,
       col = c("blue", "grey", "red")[findExtrema(x[, 2L]) + 2L])

# use the
}

