% Generated by roxygen2 (4.0.2): do not edit by hand
\name{arrayTtest}
\alias{arrayTtest}
\title{Point-to-point t-tests (potentially with TFCE correction) on arrays}
\usage{
arrayTtest(arraydat, arraydat2, paired = FALSE, groups = NULL, mu = 0,
  var_equal = TRUE, id_dim = "id", verbose = TRUE, nperm = 999L,
  useparallel = TRUE, par_method = c("default", "snow", "multicore"),
  ncores = NULL, cl = NULL, usetfce = TRUE, tfce_options = NULL,
  seed = NULL)
}
\arguments{
\item{arraydat}{a numeric array with named dimnames containing EEG (or
other) data. Missing values are not allowed. Must have at least three
dimensions with names "chan", "time", and "id" (see also id_dim)}

\item{arraydat2}{a numeric array with named dimnames containing EEG (or
other) data. If provided, see the parameter \code{paired} for running
dependent or independent-samples t-tests}

\item{paired}{logical scalar, only used if arraydat2 is provided. If paired
is FALSE (default), the function computes independent samples t-tests,
otherwise paired samples t-tests are performed}

\item{groups}{provides an alternative (and more efficient) way to perform
independent samples t-tests; a character, factor, or integer vector which
defines group membership. Groups is ignored if arraydat2 is not missing.
NA values code subjects to drop.}

\item{mu}{a numeric scalar indicating the true value of the mean (or
difference between means, if two-sample tests are performed)}

\item{var_equal}{a logical scalar whether the variances are equal (only
relevant for independent-samples t-tests). If TRUE (default), the pooled
variance is used to estimate the variance, otherwise the Welch (or
Satterthwaite) approximation to the degrees of freedom is used.}

\item{id_dim}{name of the dimension which identifies the subjects
(default: "id")}

\item{verbose}{logical value indicating if p-values should be computed for
the traditional t-test results}

\item{nperm}{integer value giving the number of permutations (default: 999L)}

\item{useparallel}{logical value; if TRUE (default), computations are done
in parallel}

\item{par_method}{parallelization method; can be set explicitly to "snow" or
"multicore" (ignored on Windows OS), or chosen automatically ("default").
Ignored if cl is provided.}

\item{ncores}{integer value corresponding to the number of cores;
if NULL (default), it is set to the maximum number of cores available.
Ignored if cl is provided.}

\item{cl}{a cluster definition; if NULL (default), it is set up automatically}

\item{usetfce}{logical value whether TFCE (threshold-free cluster enhancement)
correction should also be computed (default: TRUE)}

\item{tfce_options}{a named list containing the channel neighbourhood matrix
(named ChN, no default) and the vector of the E/H parameters (named EH,
defaults to c(0.66, 2))}

\item{seed}{an integer value which specifies a seed (default: NULL)}
}
\value{
A list object with t-values, TFCE-corrected t-values and
permutation-based p-values (if requested)
}
\description{
\code{arrayTtest} performs point-to-point t-tests on arrays.
Permutation-based p-values and Threshold-free Cluster Enhancement (TFCE)
correction can be requested.
}
\details{
The function assumes that the input array contains at least three
named dimensions: chan (corresponding to the channels [electrodes]) and time
(corresponding to time points), and \code{id_dim} (corresponding to subjects).
All other dimensions are treated in a similar way as chan and time, that is
separate t-tests are computed for each level of those dimensions.
}
\examples{
# example dataset
data(erps)
dat_id <- attr(erps, "id") # to get group memberships
chan_pos <- attr(erps, "chan") # needed for TFCE correction

# compare controls and dyslexics with traditional indep. samples t-test;
# comparison is performed for each time sample, channel and experimental
# condition separately (altogether 81972 tests - note the speed)
system.time(
    result_eegr <- arrayTtest(erps, groups = dat_id$group, nperm = 0L,
                              var_equal = FALSE, usetfce = FALSE)
)

# the built-in R function (t.test) provides the same result, but running it on
# the full dataset would take much more time;
# here we take a subsample of the data
sub <- list(chan = "F4", time = "200", stimclass = "B", pairtype = "ident")
result_ttest <- t.test(subsetArray(erps, sub) ~ dat_id$group)

# to check that they are equivalent, we have to remove the attributes
eegr_t <- as.vector(subsetArray(result_eegr$effect_t_obs, sub))
eegr_p <- as.vector(subsetArray(attr(result_eegr$effect_t_obs, "pvalues"), sub))
stopifnot(
    all.equal(as.vector(result_ttest$statistic), eegr_t),
    all.equal(as.vector(result_ttest$p.value), eegr_p)
)

# Now let's use TFCE correction; to do that, one needs a channel neigbourhood
# matrix and has to use randomization. We will simplify a bit the data to
# decrease the computational burden.
# 1) get channel neighbourhoods (type ?chanNb)
ChN <- chanNb(chan_pos, alpha = 0.7)

# 2) analyze only stimclass "B" and pairtype "ident"
tempdat <- subsetArray(erps, list(stimclass = "B", pairtype = "ident"))

# 3) run computations (now with only 499 permutations, and using 2 CPU-cores)
result_tfce <- arrayTtest(tempdat, groups = dat_id$group, var_equal = FALSE,
                          nperm = 499L, ncores = 2L, usetfce = TRUE,
                          tfce_options = list(ChN = ChN))

# 4) compare the traditional and TFCE-corrected p-values
p_trad <- attr(result_tfce$effect_t_obs, "pvalues")
p_tfce <- result_tfce$perm_pvalues
p_all <- bindArrays(trad = p_trad, tfce = p_tfce, along_name = "method")

# 5) plot p-values after -log transform for better discriminability
# note how the sporadic effects disappear after TFCE correction
p_plot <- imageValues(-log(p), wrap = "~method")
colorize(p_plot)
}

