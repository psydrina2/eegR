% Generated by roxygen2 (4.0.2): do not edit by hand
\name{transformArray}
\alias{transformArray}
\title{Data preparation mainly aimed at facilitating plotting in lattice or ggplot2}
\usage{
transformArray(formula, data, group = NULL, subset = NULL, datfr = TRUE,
  auto_dimtype = TRUE, ...)
}
\arguments{
\item{formula}{an object of class "formula" (or one that can be coerced to
that class): a symbolic description of the transformation steps before
converting the \code{array} to a \code{data.frame}. The details of how to
specify the transformations are given under ‘Details’.}

\item{data}{a matrix or an array. Must have named dimnames.}

\item{group}{a list of grouping factors in the order of appearance in the
transformation formula (see 'Details'). If a named list is provided, those
names are used as the names of dimnames for the given grouping dimensions.
It can be a simple vector if there are only one splitting factor.}

\item{subset}{a list of subsetting vectors on the input array passed to
\code{\link{subsetArray}} before any transformation steps}

\item{datfr}{a logical value (default: TRUE) if the resulting array shall be
transformed to a data.frame}

\item{auto_dimtype}{a logical value (default: TRUE) if dimension types
shall be automatically transformed to "logical", "integer", "numeric" or
"factor". Ignored if datfr is FALSE or if dim_types is explicitly provided.}

\item{...}{additional parameters to be passed to \code{\link{array2df}}}
}
\value{
A data.frame if datfr is TRUE, and an array if datfr is FALSE
}
\description{
\code{transformArray} provides several options to transform an array to a
a data.frame which enables direct plotting in lattice or ggplot2
afterwards. It can also be used for analyses purposes without data.frame
conversion if compact code is desirable.
}
\details{
The formula interface of \code{transformArray} shall be given in
the form of
\code{whateverFn(response_name, args) ~ dimA + .(dimC, dimD)}
Dimensions which are not present on the right hand side (RHS) of the formula
(e.g., dimB) are collapsed by calling \code{\link{avgDims}}. A simple .
can be used in the RHS and means "all dimensions not otherwise present in
the formula".

Dimensions in parentheses (dimC and dimD, note the dot before
the parenthesis) refer to the to-be-splitted dimensions (the corresponding
list of splitting vectors must be given in the \code{group} argument).
Splitting is performed by calling \code{\link{splitArray}}, and the splitted
dimensions are immediately collapsed in the resulting list by calling
\code{\link{avgDims}}.

The left-hand side (LHS) of the formula provides the name of the response
variable ("y") if data.frame conversion is requested (which is the default),
and also allows arbitrary computations (e.g., calling \code{\link{compGfp}}
on the array.

If there were any splitting factors, the resulting list is
back-transformed to an array. After the transformations, the array is
converted to a data.frame if \code{datfr} is TRUE.
}
\examples{
# example dataset
data(erps)
dat_id <- attr(erps, "id") # to get reading group memberships

# collapse all dimensions except for stimclass and pairtype
str(transformArray(y ~ stimclass + pairtype, erps))

# analyze separately dyslexic and control subjects, also compute Global Field
# Power
res1 <- transformArray(compGfp(y, keep_channels = TRUE) ~ . + .(id),
                       erps, list(readgroup = dat_id$group))

# the same with much more typing
res2 <- splitArray(erps, "id", list(readgroup = dat_id$group))
split_dnn <- dimnames(res2)
names(split_dnn) <- names(dim(res2))
res2 <- lapply(res2, avgDims, "id")
res2 <- lapply(res2, compGfp, keep_channels = TRUE)
res2 <- bindArrays(res2, along = 0L)
res2 <- dim2multidim(res2, 1, expand.grid(split_dnn))
res2 <- array2df(res2, response_name = "y", dim_types = "factor")
res2$time <- as.integer(as.character(res2$time))
stopifnot(identical(res1, res2))
}

