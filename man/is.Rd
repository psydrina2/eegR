% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/is.R
\name{is}
\alias{is}
\alias{isBetween}
\alias{isEqual}
\alias{isExtremum}
\alias{isLocalMaximum}
\alias{isLocalMinimum}
\alias{isMaximum}
\alias{isMinimum}
\alias{isNegative}
\alias{isPattern}
\alias{isPositive}
\title{Test logical statements on data points}
\usage{
isPattern(pattern., strict. = TRUE, ...)

isEqual(ref., tol. = .Machine$double.eps^0.5, strict. = TRUE, ...)

isBetween(lwr. = -Inf, upr. = Inf, closed. = c("both", "none", "lwr",
  "upr"), strict. = TRUE, ...)

isNegative(strict. = TRUE, ...)

isPositive(strict. = TRUE, ...)

isExtremum(what. = c("both", "min", "max"), strict. = TRUE, ...)

isLocalMaximum(strict. = TRUE, ...)

isLocalMinimum(strict. = TRUE, ...)

isMaximum(strict. = TRUE, ...)

isMinimum(strict. = TRUE, ...)
}
\arguments{
\item{pattern.}{a character regexp pattern, see the 'pattern' argument in
\code{\link{grepl}}}

\item{strict.}{logical value whether the tested condition is obligatory
(TRUE, the default) or optional (FALSE). Only used for combining multiple
tests (not available at the moment).}

\item{...}{further arguments passed to the wrapped function (see Functions
for details)}

\item{ref.}{the reference value or a vector (or matrix/array) of reference
values.}

\item{tol.}{tolerance}

\item{lwr.,upr.}{numeric values referring to the lower and upper limit
(the defaults are -Inf and Inf, respectively). Both lwr. and upr. can be
scalars and vectors as well.}

\item{closed.}{the limit which is closed; can be "both" (the default),
"none", lwr" or "upr"}

\item{what.}{specifies whether minima ("min"), maxima ("max") or
extrema ("both", the default) should be tested}
}
\description{
\code{is*} are functions which produce functions to test logical statements
on each data point of an atomic object (vector, matrix, or array). See
Details for the general idea, Functions for the short function-specific
descriptions and the section Use cases for short examples.
}
\details{
All \code{is*} functions return a function which has only one
argument, \code{x} (the data object to test). A second major rule is that
all functions returned by an \code{is*} function return a logical object
of the same shape as the input object. The third rule is that the function
returned by any \code{is*} function has an attribute called \code{.MUST}.
This affects the way how the results are combined for joint logical tests
(more on this later).
\cr
}
\section{Functions}{
\itemize{
\item \code{isPattern}: produces a function to test whether the values in an atomic
object match a pre-specified character pattern. See \code{\link{grepl}} for
further details and additional arguments it accepts.

\item \code{isEqual}: produces a function to test whether the values in an atomic
object are equal to a (vector of) reference value(s) with a given tolerance.
The returned function accepts objects of any type for which \code{asNumeric}
does not fail (see the documentation of \code{\link{asNumeric}}).

\item \code{isBetween}: produces a function to test whether
the values in an atomic object are between pre-specified limits.
The returned function accepts objects of any type for which \code{asNumeric}
does not fail (see the documentation of \code{\link{asNumeric}}).

\item \code{isNegative}: produces a function to test whether the values in an atomic
object are negative. The returned function accepts
objects of any type for which \code{asNumeric}
does not fail (see the documentation of \code{\link{asNumeric}}).

\item \code{isPositive}: produces a function to test whether the values in an atomic
object are positive. The returned function accepts
objects of any type for which \code{asNumeric}
does not fail (see the documentation of \code{\link{asNumeric}}).

\item \code{isExtremum}: produces a function to test whether the the values in an
atomic object are local or global extrema. See \code{\link{findExtrema}}
for additional details and further arguments. The returned function accepts
objects of any type for which \code{asNumeric}
does not fail (see the documentation of \code{\link{asNumeric}}).

\item \code{isLocalMaximum}: a shorthand for \code{isExtremum("max", strict., ...)}. See
\code{\link{findExtrema}} for additional details and further arguments.

\item \code{isLocalMinimum}: a shorthand for \code{isExtremum("min", strict., ...)}. See
\code{\link{findExtrema}} for additional details and further arguments.

\item \code{isMaximum}: a shorthand for
\code{isExtremum("max", strict., global = TRUE, ...)}. See
\code{\link{findExtrema}} for additional details and further arguments.

\item \code{isMinimum}: a shorthand for
\code{isExtremum("min", strict., global = TRUE, ...)}. See
\code{\link{findExtrema}} for additional details and further arguments.
}}
\section{Use cases}{

\subsection{\code{is*} as simple pre-defined test}{
A very basic use case is to pre-define a logical rule and apply it to several
objects. For example one can define\cr
\code{rangeTest <- isBetween(200, 300)}\cr
and use this rule to check for whatever numeric or numeric-like character
vector, matrix or array whether the values are between 200 and 300. If
\code{x} denotes the object, \code{rangeTest(x)} returns a logical object
of the same length and shape as \code{x} with TRUEs for values between 200
and 300 and FALSE otherwise.
}
\subsection{\code{is*} as function argument}{
\code{is*} functions come in especially handy if they are used as function
arguments.\cr
For example the code \code{subsetArray(erps, time = isBetween(200, 300))} is
a very compact and readable way of subsetting the \code{erps} data array
on its \code{time} dimension, selecting only that part of the array where
\code{time >= 200 & time <= 300}. Note that this allows the definition
of a subsetting rule without knowing in advance how the object which is to
be subsetted looks like. For example you can define
\code{sub_def <- isBetween(200, 300)} beforehand and use \code{sub_def} as
an argument in \code{subsetArray} for all data arrays if all of them have a
\code{time} dimension measured in the same unit (note that the resolution and
the time range may be different).
}
}
\examples{
# example for isPattern
# note how we pass the 'ignore.case' argument to the internally used
# grepl() function (see ?grepl)
check_start_a <- isPattern("^a", ignore.case = TRUE)
stopifnot(identical(
    check_start_a(c("a", "A", "ba")),
    structure(c(TRUE, TRUE, FALSE), .MUST = TRUE)
))
#
# example for isEqual
check_zero <- isEqual(0, tol. = 1e-4)
stopifnot(identical(
    check_zero(c("0", "0.000001", "1")),
    structure(c(TRUE, TRUE, FALSE), .MUST = TRUE)
))

# note that just like for other is* functions, the reference and the
# tolerance can be vectors (or even matrices or arrays), not only scalars,
# and its values are recycled or cropped if necessarily to match the length
# of the 'x' object
check_values <- isEqual(c(0, 1, 2), strict. = FALSE)
stopifnot(identical(
    check_values(c(0, 1.1, 2, 1e-9)),
    structure(c(TRUE, FALSE, TRUE, TRUE), .MUST = FALSE)
))
#
# example for isBetween();
# note that lwr_ and upr_ might be given in reversed order
check_0_100 <- isBetween(100, 0)
stopifnot(identical(
    check_0_100(c(-1, 1, 101)),
    structure(c(FALSE, TRUE, FALSE), .MUST = TRUE)
))
#
# example for isExtremum
# note how we can pass the 'global' and 'tail' arguments to the internal
# findExtrema() function (see ?findExtrema)
check_global_extr <- isExtremum(global = TRUE, tail = "do_not_care")
stopifnot(identical(
    check_global_extr(c(-1, 1, 0, 100, 50)),
    structure(c(TRUE, FALSE, FALSE, TRUE, FALSE), .MUST = TRUE)
))
}

